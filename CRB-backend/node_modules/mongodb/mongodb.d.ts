const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');

// ðŸ”¥ âœ… FIXED - ACTUAL COLLECTION NAMES (Tere Models se match)
const COLLECTIONS = {
  accounts: 'bankaccounts',      // BankAccount.js model
  loans: 'loans',                // Loan.js model  
  cards: 'cards',                // Card.js model
  investments: 'investments'     // Investment.js model
};

// ================================
// ðŸ”¥ COMPLETE DASHBOARD STATS - CORRECT COLLECTIONS
// ================================
router.get('/stats', async (req, res) => {
  try {
    const db = mongoose.connection.db;
    
    // âœ… ACTUAL MODEL COLLECTIONS ONLY
    const stats = await Promise.all([
      db.collection(COLLECTIONS.accounts).countDocuments({ status: 'pending' }),
      db.collection(COLLECTIONS.loans).countDocuments({ status: 'pending' }),     // âœ… Fixed 'Pending' â†’ 'pending'
      db.collection(COLLECTIONS.cards).countDocuments({ status: 'pending' }),
      db.collection(COLLECTIONS.investments).countDocuments({ status: 'pending' })
    ]);

    res.json({
      totalPending: stats[0] + stats[1] + stats[2] + stats[3],
      accounts: { pending: stats[0] },
      loans: { pending: stats[1] },
      cards: { pending: stats[2] },
      investments: { pending: stats[3] },
      timestamp: new Date().toISOString()
    });
  } catch (e) {
    console.error('âŒ Stats Error:', e);
    res.json({
      totalPending: 0,
      accounts: { pending: 0 },
      loans: { pending: 0 },
      cards: { pending: 0 },
      investments: { pending: 0 }
    });
  }
});

// ================================
// ðŸ”¥ RECENT PENDING - Quick Actions Dashboard
// ================================
router.get('/recent', async (req, res) => {
  try {
    const db = mongoose.connection.db;
    const recent = await Promise.all([
      db.collection(COLLECTIONS.accounts)
        .find({ status: 'pending' })
        .sort({ createdAt: -1 })
        .limit(3)
        .toArray(),
      db.collection(COLLECTIONS.loans)
        .find({ status: 'pending' })      // âœ… Fixed case
        .sort({ submittedOn: -1 })
        .limit(3)
        .toArray(),
      db.collection(COLLECTIONS.cards)
        .find({ status: 'pending' })
        .sort({ appliedAt: -1 })
        .limit(3)
        .toArray(),
      db.collection(COLLECTIONS.investments)
        .find({ status: 'pending' })
        .sort({ submittedOn: -1 })
        .limit(3)
        .toArray()
    ]);

    const combined = [
      ...recent[0].map(a => ({ ...a, module: 'accounts', type: a.accountType || 'Account' })),
      ...recent[1].map(l => ({ ...l, module: 'loans', type: l.loanType || 'Loan' })),
      ...recent[2].map(c => ({ ...c, module: 'cards', type: c.applicationType?.replace('Card', '') || 'Card' })),
      ...recent[3].map(i => ({ ...i, module: 'investments', type: i.investmentType || 'Investment' }))
    ].sort((a, b) => 
      new Date(b.createdAt || b.submittedOn || b.appliedAt) - new Date(a.createdAt || a.submittedOn || a.appliedAt)
    ).slice(0, 10);

    res.json(combined);
  } catch (e) {
    console.error('âŒ Recent Error:', e);
    res.json([]);
  }
});

// ================================
// ðŸ”¥ ACCOUNTS - Single Collection
// ================================
router.get('/accounts', async (req, res) => {
  try {
    const { status, limit = 50, page = 1 } = req.query;
    const skip = (page - 1) * Number(limit);
    
    const query = status ? { status } : {};
    const accounts = await mongoose.connection.db
      .collection(COLLECTIONS.accounts)
      .find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(Number(limit))
      .toArray();
    
    const total = await mongoose.connection.db.collection(COLLECTIONS.accounts).countDocuments(query);
    
    res.json({
      success: true,
      total,
      page: Number(page),
      count: accounts.length,
      data: accounts
    });
  } catch (e) {
    console.error('âŒ Accounts Error:', e);
    res.json([]);
  }
});

router.put('/accounts/:id/:status(approved|rejected|pending)', async (req, res) => {
  try {
    const { id, status } = req.params;
    const result = await mongoose.connection.db.collection(COLLECTIONS.accounts).updateOne(
      { _id: mongoose.Types.ObjectId(id) },
      { $set: { status, updatedAt: new Date() } }
    );
    
    res.json({ 
      success: result.modifiedCount > 0,
      message: `Account ${status} successfully!`
    });
  } catch (e) {
    console.error('âŒ Update Account Error:', e);
    res.status(400).json({ error: e.message });
  }
});

// ================================
// ðŸ”¥ LOANS
// ================================
router.get('/loans', async (req, res) => {
  try {
    const { status, limit = 50, page = 1 } = req.query;
    const skip = (page - 1) * Number(limit);
    
    const query = status ? { status } : {};
    const loans = await mongoose.connection.db
      .collection(COLLECTIONS.loans)
      .find(query)
      .sort({ submittedOn: -1 })
      .skip(skip)
      .limit(Number(limit))
      .toArray();
    
    const total = await mongoose.connection.db.collection(COLLECTIONS.loans).countDocuments(query);
    
    res.json({
      success: true,
      total,
      page: Number(page),
      count: loans.length,
      data: loans
    });
  } catch (e) {
    console.error('âŒ Loans Error:', e);
    res.json([]);
  }
});

router.put('/loans/:id/:status(approved|rejected|pending)', async (req, res) => {
  try {
    const { id, status } = req.params;
    const result = await mongoose.connection.db.collection(COLLECTIONS.loans).updateOne(
      { _id: mongoose.Types.ObjectId(id) },
      { 
        $set: { 
          status, 
          ...(status === 'approved' && { approvedAt: new Date() }),
          ...(status === 'rejected' && { rejectedAt: new Date() }),
          updatedAt: new Date() 
        } 
      }
    );
    
    res.json({ 
      success: result.modifiedCount > 0,
      message: `Loan ${status} successfully!`
    });
  } catch (e) {
    console.error('âŒ Update Loan Error:', e);
    res.status(400).json({ error: e.message });
  }
});

// ================================
// ðŸ”¥ CARDS - Single Collection
// ================================
router.get('/cards', async (req, res) => {
  try {
    const { status, type, limit = 50, page = 1 } = req.query;
    const skip = (page - 1) * Number(limit);
    
    let query = {};
    if (status) query.status = status;
    if (type === 'debit' || type === 'credit') {
      query.applicationType = type === 'debit' ? 'debitCard' : 'creditCard';
    }
    
    const cards = await mongoose.connection.db
      .collection(COLLECTIONS.cards)
      .find(query)
      .sort({ appliedAt: -1 })
      .skip(skip)
      .limit(Number(limit))
      .toArray();
    
    const total = await mongoose.connection.db.collection(COLLECTIONS.cards).countDocuments(query);
    
    res.json({
      success: true,
      total,
      page: Number(page),
      count: cards.length,
      data: cards
    });
  } catch (e) {
    console.error('âŒ Cards Error:', e);
    res.json([]);
  }
});

router.put('/cards/:id/:status(approved|rejected|pending)', async (req, res) => {
  try {
    const { id, status } = req.params;
    const result = await mongoose.connection.db.collection(COLLECTIONS.cards).updateOne(
      { _id: mongoose.Types.ObjectId(id) },
      { $set: { status, updatedAt: new Date() } }
    );
    
    res.json({ 
      success: result.modifiedCount > 0,
      message: `Card ${status} successfully!`
    });
  } catch (e) {
    console.error('âŒ Update Card Error:', e);
    res.status(400).json({ error: e.message });
  }
});

// ================================
// ðŸ”¥ INVESTMENTS
// ================================
router.get('/investments', async (req, res) => {
  try {
    const { status, limit = 50, page = 1 } = req.query;
    const skip = (page - 1) * Number(limit);
    
    const query = status ? { status } : {};
    const investments = await mongoose.connection.db
      .collection(COLLECTIONS.investments)
      .find(query)
      .sort({ submittedOn: -1 })
      .skip(skip)
      .limit(Number(limit))
      .toArray();
    
    const total = await mongoose.connection.db.collection(COLLECTIONS.investments).countDocuments(query);
    
    res.json({
      success: true,
      total,
      page: Number(page),
      count: investments.length,
      data: investments
    });
  } catch (e) {
    console.error('âŒ Investments Error:', e);
    res.json([]);
  }
});

router.put('/investments/:id/:status(approved|rejected|pending)', async (req, res) => {
  try {
    const { id, status } = req.params;
    const result = await mongoose.connection.db.collection(COLLECTIONS.investments).updateOne(
      { _id: mongoose.Types.ObjectId(id) },
      { 
        $set: { 
          status, 
          ...(status === 'approved' && { approvedAt: new Date() }),
          ...(status === 'rejected' && { rejectedAt: new Date() }),
          updatedAt: new Date() 
        } 
      }
    );
    
    res.json({ 
      success: result.modifiedCount > 0,
      message: `Investment ${status} successfully!`
    });
  } catch (e) {
    console.error('âŒ Update Investment Error:', e);
    res.status(400).json({ error: e.message });
  }
});

// ================================
// ðŸ”¥ GLOBAL SEARCH
// ================================
router.get('/search', async (req, res) => {
  const { q, type } = req.query;
  if (!q) return res.json({ results: [] });

  try {
    const db = mongoose.connection.db;
    let searchResults = [];

    if (!type || type === 'all') {
      searchResults = await Promise.all([
        db.collection(COLLECTIONS.loans)
          .find({ $or: [{ loanType: { $regex: q, $options: 'i' } }, { refNo: { $regex: q, $options: 'i' } }] })
          .limit(5)
          .toArray(),
        db.collection(COLLECTIONS.accounts)
          .find({ $or: [{ fullName: { $regex: q, $options: 'i' } }, { refNo: { $regex: q, $options: 'i' } }] })
          .limit(5)
          .toArray(),
        db.collection(COLLECTIONS.cards)
          .find({ $or: [{ fullName: { $regex: q, $options: 'i' } }, { refNo: { $regex: q, $options: 'i' } }] })
          .limit(5)
          .toArray(),
        db.collection(COLLECTIONS.investments)
          .find({ $or: [{ applicantName: { $regex: q, $options: 'i' } }, { refNo: { $regex: q, $options: 'i' } }] })
          .limit(5)
          .toArray()
      ]);
    }

    res.json({
      query: q,
      results: [...searchResults.flat()]
    });
  } catch (e) {
    console.error('âŒ Search Error:', e);
    res.json({ results: [] });
  }
});

// ================================
// ðŸ”¥ HEALTH CHECK
// ================================
router.get('/test', (req, res) => {
  res.json({
    message: "âœ… FULL MongoDB Admin Panel LIVE!",
    collections: Object.values(COLLECTIONS),
    endpoints: [
      '/stats', '/recent', '/accounts', '/loans', 
      '/cards', '/investments', '/search'
    ],
    status: mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected',
    timestamp: new Date().toISOString()
  });
});

module.exports = router;
